// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}


model Conversation {
  ConvId          String @id @default(uuid())
  sender          User   @relation("conversationA", fields: [senderId], references: [UserId])
  senderId        String
  receiver        User   @relation("conversationB", fields: [receiverId], references: [UserId])
  receiverId      String
  messages        Message[]
}

model Status {
  statusId   String    @id @default(uuid())
  user       User      @relation("userStatus", fields: [userId], references: [UserId], onDelete: Cascade)
  userId     String    @unique
  isOnline   Boolean   @default(false)
  inGame     Boolean   @default(false)
  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @default(now())
}

model Message {
  MsgId           String @id @default(uuid())
  content         String
  sendAt          DateTime  @default(now())
  conversation    Conversation @relation(fields: [conversationId], references: [ConvId])
  conversationId  String       
}

model Friend {
  FriendshipId       String @id @default(uuid())
  userA              User @relation("relationA",fields: [userAId], references: [UserId], onDelete: Cascade) // user that requested friendship first
  userAId            String
  loginA             String 
  userB              User @relation("relationB",fields: [userBId], references: [UserId], onDelete: Cascade)
  userBId            String
  loginB             String 
  isFriends          Boolean @default(false)
}

model  Block {
  BlockId       String @id @default(uuid())
  blockBy       User   @relation("BlockedBy",fields: [blockedById], references: [UserId], onDelete: Cascade)
  blockedById   String
  blockByLogin  String
  blocked       User   @relation("Blocked",fields: [blockedId], references: [UserId], onDelete: Cascade)
  blockedId     String
  blockedLogin  String
  BlockeddAt     DateTime @default(now())
}


// channel Models

model channel {
  ChannelId      String @id @default(uuid())
  channelName    String @unique
  createdAt      DateTime  @default(now())
  messages       MsgChannel[] @relation("MessagesChannel")
  members        MembershipChannel[] @relation("MembersChannel")
  password       String?
}

model MembershipChannel {
  MembershipId      String @id @default(uuid())
  createdAt         DateTime  @default(now())
  nickname          String?
  channel           channel @relation("MembersChannel",fields: [channelId], references: [ChannelId])
  channelName       String
  channelId         String  
  user              User  @relation("Membership",fields: [userId], references: [UserId])
  userId            String  @unique
}

model MsgChannel {
  MsgChannelId        String @id @default(uuid())
  senderUsername      String              
  content             String
  sendAt              DateTime  @default(now())
  channel             channel @relation("MessagesChannel",fields: [channelId], references: [ChannelId])
  channelId           String
}

model User {
  UserId              String @id @default(uuid())
  login               String @unique()
  username            String @unique
  email               String @unique
  photo               String?
  url                 String?
  // Friends
  friendsAddedUser         Friend[] @relation("relationA")
  friendsAddeBydUser       Friend[] @relation("relationB")

  // Block
  blockedBy             Block[] @relation("BlockedBy")
  blocked               Block[] @relation("Blocked")

  // conversations
  conversationsA        Conversation[]  @relation("conversationA")
  conversationsB        Conversation[]  @relation("conversationB")

  // status
  status   Status?      @relation("userStatus")

  // channel
  memberships     MembershipChannel[] @relation("Membership")

  // Stats
  stats           Stats? @relation("userStats")

  //matches
  matchhistoryA   match[] @relation("matchA")
  matchhistoryB   match[] @relation("matchB")
}


model Stats {
  StatsId    String    @id @default(uuid())
  user       User      @relation("userStats", fields: [userId], references: [UserId], onDelete: Cascade)
  userId     String    @unique
  wins       Int       @default(0)
  losses     Int       @default(0)
  ladder     Int       @default(0)
}

model match {
  matchyId     String    @id @default(uuid())
  userA        User      @relation("matchA",fields: [userAId], references: [UserId], onDelete: Cascade)
  userAId      String
  scoreA       Int
  userB        User      @relation("matchB",fields: [userBId], references: [UserId], onDelete: Cascade)
  userBId      String
  scoreB       Int      @default(0)
  winner       Int      @default(0)   // userA :0  , userB:1
  finishedAt   DateTime @default(now())
}


